针对您的问题，由于数据规模较小（200~300名球员），最推荐且最有效的算法是**整数线性规划 (Integer Linear Programming, ILP)**。

这是解决此类“背包问题变种”或“梦幻体育阵容优化”问题的行业标准方法。它能保证找到**数学上的全局最优解**（即确定性算法），而不是近似解，且在几秒钟内即可完成计算。

以下是详细的算法设计与实现方案。

---

### 1. 问题建模

我们将问题转化为一个数学模型。我们的目标是最大化“总加权得分”，同时满足位置、人数和薪资约束。

#### 变量定义

对于每一位球员 （ 到 ），我们引入二进制决策变量（0或1）：

* ：球员  是否首发打 PG
* ：球员  是否首发打 SG
* ：球员  是否首发打 SF
* ：球员  是否首发打 PF
* ： 球员  是否首发打 C
* ：球员  是否进入替补席

#### 目标函数 (Maximize)

我们要最大化总评分：



*(解释：如果首发，得分为2倍；如果替补，得分为1倍)*

#### 约束条件

1. **唯一性约束**：一名球员最多只能担任一个角色（要么首发某个位置，要么替补，要么不选）。


2. **首发位置人数约束**：每个首发位置必须恰好有1人。




...以此类推至 C。
3. **替补人数约束**：替补必须恰好有7人。


4. **薪资约束**：总薪资不能超过上限。


5. **位置资格约束**：如果球员  的属性不能打位置 ，则 。
* 例如：如果球员是“中锋”，则  必须为 0。



---

### 2. Python 算法实现

我们将使用 Python 的 `pulp` 库，这是一个非常流行且易用的线性规划库。

#### 步骤 1: 准备环境

```bash
pip install pulp

```

#### 步骤 2: 完整代码

您可以直接复制以下代码运行。我已根据您的描述构建了位置映射逻辑。

```python
import pulp

# 1. 定义数据结构 (示例数据，实际使用时请替换为您的200-300名球员列表)
# 假设数据格式: {'id': 1, 'name': 'PlayerA', 'score': 25.5, 'salary': 12000000, 'position': '后卫'}
players_data = [
    # ... 这里填入您的球员数据 ...
    # 示例构造一些假数据用于演示
    {'id': i, 'name': f'P{i}', 'score': 10 + (i % 20), 'salary': 1000000 + (i * 10000), 'position': pos}
    for i, pos in enumerate(['后卫', '后卫-前锋', '前锋', '后卫-前锋', '中锋'] * 50) # 生成250个球员
]

# 2. 定义位置映射规则 (根据您的 Prompt)
# Key: 球员属性, Value: 可以胜任的首发位置列表
# 注意：您提到的"后卫-前锋"既能打SG/SF，又能打PF/C。
# 为了逻辑严谨，如果输入数据中这两个"后卫-前锋"是同一种字符，我们将取并集，或者您需要在数据清洗时区分它们。
# 此处假设"后卫-前锋"可以打 SG, SF, PF, C (根据您的两处描述合并)
# 如果您的数据中"后卫-前锋"分两种不同写法，请在此处修改。

position_map = {
    '后卫': ['PG', 'SG'],
    '后卫-前锋': ['SG', 'SF', 'PF', 'C'], # 包含了您描述的所有情况
    '前锋': ['SF', 'PF'],
    '中锋': ['C']
}
starter_slots = ['PG', 'SG', 'SF', 'PF', 'C']
SALARY_CAP = 187895000

def solve_roster(players):
    # --- 模型初始化 ---
    prob = pulp.LpProblem("Basketball_Roster_Optimization", pulp.LpMaximize)

    # --- 决策变量 ---
    # build_vars: 字典，key为 (player_id, role), value为二进制变量
    # role 可以是 'PG', 'SG', 'SF', 'PF', 'C' (首发) 或 'BENCH' (替补)
    x = {} 
    
    for p in players:
        pid = p['id']
        p_pos = p['position']
        
        # 1. 创建首发变量 (仅当球员有资格打该位置时)
        allowed_slots = position_map.get(p_pos, [])
        for slot in allowed_slots:
            x[(pid, slot)] = pulp.LpVariable(f"x_{pid}_{slot}", cat='Binary')
            
        # 2. 创建替补变量 (所有人都可以打替补)
        x[(pid, 'BENCH')] = pulp.LpVariable(f"x_{pid}_BENCH", cat='Binary')

    # --- 目标函数 ---
    # Maximize: 2 * Starter_Score + 1 * Bench_Score
    objective_terms = []
    for p in players:
        pid = p['id']
        score = p['score']
        
        # 首发项
        for slot in starter_slots:
            if (pid, slot) in x:
                objective_terms.append(2 * score * x[(pid, slot)])
        
        # 替补项
        if (pid, 'BENCH') in x:
            objective_terms.append(1 * score * x[(pid, 'BENCH')])
            
    prob += pulp.lpSum(objective_terms)

    # --- 约束条件 ---

    # 1. 薪资上限
    salary_terms = []
    for p in players:
        pid = p['id']
        sal = p['salary']
        # 收集该球员所有的决策变量
        player_vars = [x[(pid, role)] for role in starter_slots + ['BENCH'] if (pid, role) in x]
        for var in player_vars:
            salary_terms.append(sal * var)
    prob += pulp.lpSum(salary_terms) <= SALARY_CAP, "Total_Salary"

    # 2. 球员唯一性 (每人只能占1个坑位，或者不选)
    for p in players:
        pid = p['id']
        player_vars = [x[(pid, role)] for role in starter_slots + ['BENCH'] if (pid, role) in x]
        prob += pulp.lpSum(player_vars) <= 1, f"One_Role_{pid}"

    # 3. 首发位置填满 (每个位置必须正好有1人)
    for slot in starter_slots:
        slot_vars = [x[(pid, slot)] for p in players for pid in [p['id']] if (pid, slot) in x]
        prob += pulp.lpSum(slot_vars) == 1, f"Fill_Starter_{slot}"

    # 4. 替补席填满 (必须正好有7人)
    bench_vars = [x[(pid, 'BENCH')] for p in players for pid in [p['id']] if (pid, 'BENCH') in x]
    prob += pulp.lpSum(bench_vars) == 7, "Fill_Bench"

    # --- 求解 ---
    # 使用默认求解器 (CBC)
    status = prob.solve(pulp.PULP_CBC_CMD(msg=0))

    # --- 输出结果 ---
    if pulp.LpStatus[status] != 'Optimal':
        print("无法找到满足条件的最优解 (可能薪资限制太严或人员不足)")
        return None

    roster = {'starters': {}, 'bench': [], 'total_score': 0, 'total_salary': 0}
    
    for p in players:
        pid = p['id']
        
        # 检查是否入选首发
        for slot in starter_slots:
            if (pid, slot) in x and pulp.value(x[(pid, slot)]) == 1:
                roster['starters'][slot] = p
                roster['total_score'] += p['score'] * 2
                roster['total_salary'] += p['salary']
        
        # 检查是否入选替补
        if (pid, 'BENCH') in x and pulp.value(x[(pid, 'BENCH')]) == 1:
            roster['bench'].append(p)
            roster['total_score'] += p['score']
            roster['total_salary'] += p['salary']

    return roster

# 运行求解
result = solve_roster(players_data)

# 打印结果
if result:
    print(f"--- 最佳阵容 (总分: {result['total_score']}) ---")
    print(f"总薪资: ${result['total_salary']:,}")
    print("\n[首发名单]")
    for slot in ['PG', 'SG', 'SF', 'PF', 'C']:
        p = result['starters'].get(slot)
        if p:
            print(f"{slot}: {p['name']} (分:{p['score']}, 薪:${p['salary']:,}, 原位:{p['position']})")
            
    print("\n[替补名单]")
    for p in result['bench']:
        print(f"Bench: {p['name']} (分:{p['score']}, 薪:${p['salary']:,})")

```

### 3. 为什么选择这个算法？

对于 200~300 名球员的数据量：

1. **确定性最优 (Deterministic):** 该算法不是“猜测”或“随机尝试”，它是基于数学不等式求解边界。只要有解，它给出的就是理论上的最高分，没有之一。
2. **速度极快:** 现代计算机求解这种规模的线性规划问题通常只需要 **0.1秒到0.5秒**。
3. **可扩展性:** 如果您将来增加规则（例如“同一队不能超过2人”），只需在代码中添加一行 `prob += ...` 约束即可，非常灵活。

### 4. 关于位置规则的补充说明

您在限制中提到：

> * 属性为“后卫-前锋”的球员可以胜任SG、SF位置
> * 属性为“后卫-前锋”的球员可以胜任PF、C位置
> 
> 

这里存在文本上的重复（“后卫-前锋”出现了两次，对应的能力不同）。在代码中，我采取了**宽容处理**：只要属性是“后卫-前锋”，我假设他能打 SG, SF, PF, C 中的任意一个。

* 如果您原本的意思是数据库里有两种不同的标记（例如 "G-F" 和 "F-C"），请务必在 `position_map` 字典中将键（Key）区分开来。
